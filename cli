#! /usr/bin/env python
from __future__ import print_function

import sys
from cmd import Cmd
from lib import *
import glob
import json
from os.path import dirname, basename, isfile, isdir, expanduser, exists
from os import makedirs
sys.path.insert(0, "./lib/")

DEBUG = False

class DTShell(Cmd, object):
    NAME = 'Duckietown Shell'
    VERSION = '0.1 (beta)'
    prompt = 'dt> '
    config = {
        'version' : VERSION
    }
    config_path = expanduser('~/.dt-shell/')
    config_file = config_path+'config'

    def __init__(self):
        self.intro = "" \
            "Welcome to the Duckietown shell.\n" \
            "Version: %s\n\n" \
            "Type help or ? to list commands.\n" % self.VERSION
        # create config if it does not exist
        if not exists(self.config_path):
            makedirs(self.config_path, mode=0755)
        if not exists(self.config_file):
            self.save_config()
        # load config
        self.load_config()
        # discover commands
        commands_path = dirname(__file__)+'/commands/'
        commands = self._get_commands(commands_path)
        # load commands
        for cmd, subcmds in commands.items():
            self._load_commands( 'commands.', cmd, subcmds, 0 )
        # call super constructor
        super(DTShell, self).__init__()

    def postcmd(self, stop, line):
        if len(line.strip()) > 0:
            print('')

    def emptyline(self): pass

    def complete(self, text, state):
        res = super(DTShell, self).complete(text, state)
        if res is not None: res += ' '
        return res

    def get_version(self): return self.VERSION

    def load_config(self):
        with open(self.config_file, 'r') as fp:
            self.config = json.load(fp)

    def save_config(self):
        with open(self.config_file, 'w') as fp:
            json.dump(self.config, fp)

    def _get_commands(self, path):
        entries = glob.glob(path+"/*")
        files = [ basename(e) for e in entries if isfile(e) ]
        dirs = [ e for e in entries if isdir(e) ]
        # base case: empty dir
        if 'command.py' not in files and len(dirs) == 0: return None
        # check subcommands
        subcmds = {}
        for dir in dirs:
            f = self._get_commands( dir )
            if f is not None: subcmds[ basename(dir) ] = f
        # return
        return subcmds

    def _load_class(self, name):
        if DEBUG: print('DEBUG:: Loading %s' % name)
        components = name.split('.')
        mod = __import__(components[0])
        for comp in components[1:]:
            mod = getattr(mod, comp)
        return mod

    def _load_commands(self, package, command, sub_commands, lvl):
        # load command
        klass = None
        error_loading = False
        try:
            klass = self._load_class( package+command+'.command.DTCommand' )
        except AttributeError:
            error_loading = True
        # handle loading error and wrong class
        if error_loading:
            klass = DTCommandPlaceholder()
            if DEBUG: print( 'ERROR while loading the command `%s`' % (package+command+'.command.DTCommand',) )
        if not issubclass(klass.__class__, DTCommandAbs.__class__):
            klass = DTCommandPlaceholder()
            if DEBUG: print( 'Command `%s` not found' % (package+command+'.command.DTCommand',) )
        # initialize list of subcommands
        klass.name = command
        klass.commands = {}
        # attach first-level commands to the shell
        if lvl == 0:
            do_command = getattr(klass, 'do_command')
            complete_command = getattr(klass, 'complete_command')
            # wrap [klass, function] around a lambda function
            do_command_lam = lambda s,w: do_command(klass,s,w)
            complete_command_lam = lambda s,w,l,i,e: complete_command(klass,s,w,l,i,e)
            # add functions do_* and complete_* to the shell
            setattr( DTShell, 'do_'+command, do_command_lam )
            setattr( DTShell, 'complete_'+command, complete_command_lam )
        # stop recursion if there is no subcommand
        if sub_commands is None: return
        # load sub-commands
        for cmd, subcmds in sub_commands.items():
            if DEBUG: print('DEBUG:: Loading %s' % package+command+'.*')
            kl = self._load_commands( package+command+'.', cmd, subcmds, lvl+1 )
            if kl is not None: klass.commands[cmd] = kl
        # return class for this command
        return klass


if __name__ == '__main__':
    shell = DTShell()
    shell.cmdloop()
