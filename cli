#! /usr/bin/env python
from __future__ import print_function

import sys
from cmd import Cmd
from lib import *
import glob
import json
from git import Repo
from git.exc import NoSuchPathError, InvalidGitRepositoryError
from os.path import dirname, basename, isfile, isdir, expanduser, exists
from os import makedirs, remove
sys.path.insert(0, dirname(__file__)+"/lib/")
sys.path.insert(0, dirname(__file__)+"/commands/lib/")


DEBUG = False

class DTShell(Cmd, object):
    NAME = 'Duckietown Shell'
    VERSION = '0.1 (beta)'
    prompt = 'dt> '
    config = {}
    config_path = expanduser('~/.dt-shell/')
    config_file = config_path+'config'
    commands_path = dirname(__file__)+'/commands/'
    commands_remote_url = 'https://github.com/duckietown/duckietown-shell-commands'

    def __init__(self):
        self.intro = "" \
            "Welcome to the Duckietown shell.\n" \
            "Version: %s\n\n" \
            "Type help or ? to list commands.\n" % self.VERSION
        # create config if it does not exist
        if not exists(self.config_path):
            makedirs(self.config_path, mode=0755)
        if not exists(self.config_file):
            self.save_config()
        # load config
        self.load_config()
        # init commands
        if exists(self.commands_path) and isfile(self.commands_path):
            remove(self.commands_path)
        if not exists(self.commands_path):
            if not self._init_commands(): exit()
        # discover commands
        commands = self._get_commands(self.commands_path)
        if commands is None:
            print( 'No commands found.' )
            commands = {}
        # load commands
        for cmd, subcmds in commands.items():
            self._load_commands( 'commands.', cmd, subcmds, 0 )
        # call super constructor
        super(DTShell, self).__init__()

    def postcmd(self, stop, line):
        if len(line.strip()) > 0:
            print('')

    def emptyline(self): pass

    def complete(self, text, state):
        res = super(DTShell, self).complete(text, state)
        if res is not None: res += ' '
        return res

    def get_version(self): return self.VERSION

    def load_config(self):
        with open(self.config_file, 'r') as fp:
            self.config = json.load(fp)

    def save_config(self):
        with open(self.config_file, 'w') as fp:
            json.dump(self.config, fp)

    def _init_commands(self):
        print( 'Downloading commands...' )
        # create commands repo
        commands_repo = Repo.init( self.commands_path )
        # the repo now exists
        origin = commands_repo.create_remote('origin', self.commands_remote_url)
        # check existence of `origin`
        if( not origin.exists() ):
            print( 'The commands repository %r cannot be found. Exiting.' % origin.urls )
            return False
        # pull data
        res = origin.fetch()
        # create local.master <-> remote.master
        commands_repo.create_head('master', origin.refs.master)
        commands_repo.heads.master.set_tracking_branch(origin.refs.master)
        # the repo is there and there is a `origin` remote, merge
        commands_repo.heads.master.checkout()
        return True

    def update_commands(self):
        # create commands repo
        commands_repo = None
        try:
            commands_repo = Repo( self.commands_path )
        except (NoSuchPathError, InvalidGitRepositoryError) as e:
            # the repo does not exist
            if not self._init_commands(): return False
        # the repo exists
        print( 'Updating commands...', end='' )
        origin = commands_repo.remote('origin')
        # check existence of `origin`
        if( not origin.exists() ):
            print( 'The commands repository %r cannot be found. Exiting.' % origin.urls )
            return False
        res = origin.fetch()
        # pull data from remote.master to local.master
        commands_repo.heads.master.checkout()
        print('OK')
        # update all submodules
        print( commands_repo.submodules )
        print( 'Updating libraries...', end='' )
        commands_repo.submodule_update(recursive=True, to_latest_revision=True)

        # for submodule in commands_repo.submodules:
        #     submodule.update(recursive=True, to_latest_revision=True)


        # everything should be fine
        print('OK')
        return True

    def _get_commands(self, path, lvl=0):
        entries = glob.glob(path+"/*")
        files = [ basename(e) for e in entries if isfile(e) ]
        dirs = [ e for e in entries if isdir(e) and (lvl>0 or basename(e)!='lib') ]
        # base case: empty dir
        if 'command.py' not in files and len(dirs) == 0: return None
        # check subcommands
        subcmds = {}
        for dir in dirs:
            f = self._get_commands( dir, lvl+1 )
            if f is not None: subcmds[ basename(dir) ] = f
        # return
        return subcmds

    def _load_class(self, name):
        if DEBUG: print('DEBUG:: Loading %s' % name)
        components = name.split('.')
        mod = __import__(components[0])
        for comp in components[1:]:
            mod = getattr(mod, comp)
        return mod

    def _load_commands(self, package, command, sub_commands, lvl):
        # load command
        klass = None
        error_loading = False
        try:
            klass = self._load_class( package+command+'.command.DTCommand' )
        except AttributeError:
            error_loading = True
        # handle loading error and wrong class
        if error_loading:
            klass = DTCommandPlaceholder()
            if DEBUG: print( 'ERROR while loading the command `%s`' % (package+command+'.command.DTCommand',) )
        if not issubclass(klass.__class__, DTCommandAbs.__class__):
            klass = DTCommandPlaceholder()
            if DEBUG: print( 'Command `%s` not found' % (package+command+'.command.DTCommand',) )
        # initialize list of subcommands
        klass.name = command
        klass.level = lvl
        klass.commands = {}
        # attach first-level commands to the shell
        if lvl == 0:
            do_command = getattr(klass, 'do_command')
            complete_command = getattr(klass, 'complete_command')
            help_command = getattr(klass, 'help_command')
            # wrap [klass, function] around a lambda function
            do_command_lam = lambda s,w: do_command(klass,s,w)
            complete_command_lam = lambda s,w,l,i,e: complete_command(klass,s,w,l,i,e)
            help_command_lam = lambda s: help_command(klass,s)
            # add functions do_* and complete_* to the shell
            setattr( DTShell, 'do_'+command, do_command_lam )
            setattr( DTShell, 'complete_'+command, complete_command_lam )
            setattr( DTShell, 'help_'+command, help_command_lam )
        # stop recursion if there is no subcommand
        if sub_commands is None: return
        # load sub-commands
        for cmd, subcmds in sub_commands.items():
            if DEBUG: print('DEBUG:: Loading %s' % package+command+'.*')
            kl = self._load_commands( package+command+'.', cmd, subcmds, lvl+1 )
            if kl is not None: klass.commands[cmd] = kl
        # return class for this command
        return klass


if __name__ == '__main__':
    shell = DTShell()
    shell.cmdloop()
